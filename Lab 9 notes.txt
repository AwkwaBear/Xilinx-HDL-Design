
This weeks lab will expand upon what you have learned thus far on creating testbench behavior.

INCLUDE A SCREENSHOT OF ALL YOUR SIMULATIONS IN YOUR LAB REPORT	!!!

Lab sections 1-1 through 1-4 are MANDATORY

Section 1-5 is OPTIONAL.


Make sure you read the front matter in the lab to understand the difference between INTER-statement delays and INTRA-statement delays.

an INTER-statement delay occurs in between statements

e.g. #5 clk = 0;
	#5 clk = 1;

The delays occur at the beginning of each lines and take place between the assignment of `clk = 0` and `clk = 1`

an INTRA-statement delay occurs WITHIN an assignments 

e.g. DONE = #5 1â€™b1:

The delay in this case occurs after the `=` sign and is in the MIDDLE of an assignment

Tips for each section:
	
	Part 1-1:
		-This part uses INTER-statement delays to produce a waveform
		-The graph is referring to values in hexadecimal, values can be assigned in Hex similar to how you have assigned them in the past in binary. (e.g. 4'b1010 is equivalent to 4'hA)
			In the hex example above, '4' refers to the number of bits, 'h' refers to hexadecimal, and 'A' is '1010' in Hex
		-All you need to do in this part is simply create a project called lab9_1_1 and have it contain a testbench that creates the requested hex values at the time intervals. 
			-make sure you set your simulation time to something short like '20 ns'
			-you do not need to add an actual verilog module for a device nor do you need a constraints file
			-your project should basically be empty aside from the testbench file
			-Be sure to keep in mind that the reg for PORT_A must be an 8 bit register
	
	
	Part 1-2:
		-This part uses INTRA-statement delays to produce a waveform. 
		
		-create an empty project and a testbench similar to how you did in part 1-1
		
		-In this portion it is important to highlight the difference between BLOCKING and NON-BLOCKING assignments
		
			-Using a normal `=` sign is a BLOCKING assignment meaning subsequent statements will be BLOCKED from executing until the current line is run
				e.g. clk = #5 0;
				     clk = #6 1;
					In this case, the waveform produced will wait 5 ns then clk will be 0, then after another 6 ns clk will be 1
			-Using `<=` is a NON-BLOCKING assignment, meaning it will not wait for the first statement to complete before initiating the second statement	
				e.g. clk <= #5 0;
					 clk <= #6 1;
					 In this case, the waveform will run through both statements and the delays will happen concurrently. This means that the clk will turn to '0' after 5 ns and 1 ns later will turn to '1'
					 
		 -Use the above information to produce the waveform given in the instructions
			-the gap in output between 0 and 10 ns should be an "X" (undefined) value. This means that STREAM does not have an initial value and the first assignment is when it is defined by when you set STREAM to 0 after a 10 ns delay
	
	Part 1-3:
		-This section you will create a MUX using given behavior then create a simple testbench to verify your design
		
		-do not overthink it, this section only needs you to make a basic 4 to 1 mux using if-else-if statements and a testbench to test the outputs
		
		-The behavior of the 1bit 4 to 1 MUX is as follows
		
		-A 1-bit 4to1 MUX will have a 4bit input X[3:0], 2 select bits sel[2:0], and one output Q
			-when sel = 00, Q will be equal to whatever value is on X[0] 
			-when sel = 01, Q will be equal to whatever value is on X[1] 
			-when sel = 10, Q will be equal to whatever value is on X[2] 
			-when sel = 11, Q will be equal to whatever value is on X[3] 
			
		-Write your testbench to show every permutation of 1 and 0 on each input for each possible value for 'sel' 
			ie. sel = 00, x[0] = 0;
				sel = 00, x[0] = 1;
				sel = 01, x[1] = 0;
				sel = 01, x[1] = 1;
				etc..
		-Once you create a proper simulation then this section is complete, do not worry about the constraint file or implementing on the board obviously
		
	Part 1-4:
		-This next section is similar to part 1-3 in that you will be making a simple module and a testbench in order to prove it works properly
		
		-You will be making a grey code generator using CASE statements. If you do not know what a grey code generator is information about grey code can be found here
			https://en.wikipedia.org/wiki/Gray_code
		
		-Basically all that is required is a case statement where you assign a grey code output from the chart on that wikipedia page to the input in regular binary
		
		-The module will have the inputs and outputs prescribed in the lab instructions
		
		-Create a testbench that will count through all inputs [0000]->[1111] and also showcase the enable switch being true and false
		
		
	Part 1-5 [OPTIONAL]:
		-This portion requires you to make a counter that follows a prescribed sequence. The counter is identical to the optional portion (section 3-1) of the finite state machine lab
		
		-you have to make a moore similar to how you did in that lab.
		
		-if you completed this portion before you can simply copy and paste your code from before
		
		-The lab specifies a clock period of 10 units, this refers to clock changing state every 5 ns
			ie.  always
					#5 clk = ~clk;
		